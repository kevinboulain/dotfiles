{ config, lib, pkgs, ... }: {
  imports = [
    ./networking.nix
    ./system.nix
  ];

  # For simplicity reasons I've decided to use k3s instead of Kubernetes:
  #  - Kubernetes upgrades would require some attention:
  #    https://kubernetes.io/docs/tasks/administer-cluster/cluster-upgrade/#manual-deployments
  #    While k3s upgrades could be performed like any other update:
  #    https://docs.k3s.io/upgrades/manual#manually-upgrade-k3s-using-the-binary
  #  - Resources-wise, k3s should be more lightweight than Kubernetes (it's an
  #    explicit goal to run on small machines). k3s also embeds a bunch of
  #    components that seem to be reasonable (like Flannel, to stay simple, or
  #    containerd).
  #  - I would have rewritten the NixOS integration of Flannel (no IPv6-only
  #    support, too many ports open, ...) and Kubernetes, which detracts from
  #    actually from actually getting up and running.

  # https://docs.k3s.io/cli/token#k3s-token-1
  # TODO: secure token
  sops.secrets.token.sopsFile = ./default.yaml;

  services.k3s =
    let
      peer = builtins.elemAt config.my.mesh.peers 0;
    in
      {
        enable = true;
        role = "server";
        tokenFile = config.sops.secrets.token.path;
        # https://docs.k3s.io/datastore/ha-embedded
        # The first node initializes the cluster.
        clusterInit = peer.fqdnOrHostName == config.networking.fqdnOrHostName;
        # All others nodes join the first.
        serverAddr = if peer.fqdnOrHostName == config.networking.fqdnOrHostName then "" else "https://${peer.fqdnOrHostName}:6443";
        extraFlags = lib.strings.escapeShellArgs [
          # IPv6-only cluster.
          # https://docs.k3s.io/installation/network-options#single-stack-ipv6-networking
          "--node-ip=${config.my.mesh.address}"
          "--cluster-cidr=fd2b::/56"
          "--service-cidr=fd2c::/112"
          # The cluster runs on top of a WireGuard mesh network.
          "--flannel-backend=vxlan"
          "--flannel-iface=mesh0"  # It picks the first interface by default...
        ];
      };

  # kubelet will use autogenerated resolv.conf with nameserver 8.8.8.8
  # wtf...
  # +sysctl ipv4 forward

  # https://docs.k3s.io/installation/requirements#networking
  networking.firewall.interfaces.${config.my.mesh.interface} = {
    allowedTCPPorts = [ 2379 2380 6443 ];
    allowedUDPPorts = [ 8472 ];
  };
}
